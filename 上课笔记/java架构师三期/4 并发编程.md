
### JMM&volatile详解
### Synchronized&Lock&AQS详解
**java锁体系**
![](/img/lock.jpg)

> Synchronized -> Lock -> AQS, 三者的并发源码都在底层 Juc (java.util.concurrent)的并发框架实现，作者是道格·利 (Doug Lea)，AQS是线程安全和并发的核心框架

**保证同步线程的意义**

>多线程编程中，有可能会出现多个线程同时访问同一个共享、可变资源的情况，这个资源我们称之其为临界资源；这种资源可能是：对象、变量、文件等:
* 共享：资源可以由多个线程同时访问
* 可变：资源可以在其生命周期内被修改
* 引出的问题：由于线程执行的过程是不可控的，所以需要采用同步机制来协同对对象可变状态的访问

**那么我们怎么解决线程并发安全问题**
>实际上，所有的并发模式在解决线程安全问题时，采用的方案都是 序列化访问临界资源。即在同一时刻，只能有一个线程访问临界资源，也称作同步互斥访问

**java锁分类**
>java锁按性质可以分为：显示锁，隐式锁

>无论那种锁，都可以实现多线程阻塞，保证多个线程之间可以有序的执行，但是不保证锁包裹中同步块代码的执行指令顺序，即不保证cpu引起的指令重排

> 加锁的目的：保证多线程之间序列化的访问临界资源(即同步代码块)，Synchronized(临界状态)，同一时刻只能由一个线程访问临界资源(同步互斥访问)

* 显示锁：采用RenntrantLock(yun去key落)，实现juc并发框架的Lock，基于AQS实现，分别是Lock(), unLock(),相比Synchronize更加灵活
* 隐式锁：采用Synchronized加锁机制，为jvm内置锁，不需要手动加锁和解锁，jvm会自动加锁解锁
* Unsafe方式：通过反射底层实现手动实现，此方法会绕过虚拟机直接操作底层，不建议使用

~~~~ bash
UnsafeInstance.reflectGetUnsafe().monitorEnter(Object);
UnsafeInstance.reflectGetUnsafe().monitorExit(Object)
~~~~

**Synchronized**
> 加锁方式，适用于单例bean
* 同步实例方法，锁是当前实例对象
* 同步类方法，锁是当前类对象
* 同步代码块，锁是括号里面的对象

>实现原理：会在编译字节码文件的时候，会由jvm虚拟机，会在括号前后的代码块增加两个Monitor 监视器锁的底层指令，分别是 monitorenter / monitorexit，分别代表加锁和解锁，直到多个线程执行到monitorenter 指令时，会产生竞争来获得执行权，未得到执行权的线程会阻塞到一个waitSet等待队列中，通过自旋等待当前线程执行完成，再竞争锁，另外自旋等待中cpu时间片不会切换
>Monitor(监视器锁)：每一个对象的创建在对象头中都有一个自己的Monitor的监视器锁，基于进入与退出Monitor对象实现方法与代码块同步，监视器锁的实现依赖底层操作系统的Mutex lock（互斥锁)实现，它是一个重量级锁性能较低
>synchronized锁优化：JVM内置锁在1.5之后版本做了重大的优化，如锁粗化（LockCoarsening)、锁消除（Lock Elimination)、轻量级锁（LightweightLocking)、偏向锁（Biased Locking)、适应性自旋（Adaptive Spinning)等技术来减少锁操作的开销，，内置锁的并发性能已经基本与Lock持平
>锁状态记录：锁状态是被记录在每个对象的对象头(Mark Word)中

![synchronized](/img/synchronized.jpg)

**对象内存结构**
>HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域
* 对象头(Header)：比如 hash码，对象所属的年代，对象锁，锁状态标志，偏向
锁(线程)ID，偏向时间，数组长度(数组对象)，元数据指针(MetaDate 指向getClass对象)等
  * 分别为32个和64个Bits，官方称它为“Mark Word”，对象头信息是与对象自身定义的数据
无关的额外存储成本，可复用
  * MarkWord的32个Bits空间中的25Bits用于存储对象哈希码（HashCode），4Bits用于
存储对象分代年龄，2Bits用于存储锁标志 位，1Bit固定为0，在其他状态（轻
量级锁定、重量级锁定、GC标记、可偏向），会根据锁升级变动结构
  * 如果对象是数组类型，则需要三个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度
![makeword-detail](/img/makeword-detail.jpg)

* 实例数据(Instance Data)：即创建对象时，对象中成员变量，方法等
* 对齐填充(Padding)：对象的大小必须是8字节的整数倍，方便jvm的内存管理

![makework](/img/makework.jpg)


>实例对象内存中存储在哪？
* 如果实例对象存储在堆区时：实例对象内存在堆区，实例的引用存在栈上，实例的元数据class存在方法区或者元空间
* 如果实例对象没有线程逃逸行为：在代码编译的时候Jit会进行逃逸分析优化，当代码中没有return 新对象并且只有当前线程访问的时候，会有部分被存在当前的线程栈中，jdk 1.7后默认开启
  * XX:+DoEscapeAnalysis ： 表示开启逃逸分析 ­
  * XX:­DoEscapeAnalysis ： 表示关闭逃逸分析

~~~~ bash
// 逃逸行为，时编译器对代码的优化行为
// 1.同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可
以不考虑同步
// 2.将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远
不会逃逸，对象可能是栈分配的候选，而不是堆分配
// 3.分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问
到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中
private static void user(){
   User user = new User();

   //除非return，被其他线程访问到
   //return user;
}
~~~~

**锁消除/锁粗化**
> jvm对synchronized的优化
* 锁消除：synchronized(new Object())，类似这样的同步方法，jvm编译时不会进行加锁操作，因为这种操作不能产生多线程的互斥
* 锁粗化：相近代码块中，如果出现多个一样的synchronize同步方法的话，jvm会在编译阶段合并成一个大的synchronized块，比如多行的 StringBuffer.append() ...


**JVM内置锁优化升级过程**
>锁的升级不会降级，会由下往上的膨胀升级，直到重量级锁，jdk 1.6后升级优化了这些
* 无锁：没有线程访问的状态
* 偏向锁：适用单独线程的访问场景，开启可以提升性能10%，默认开启，偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，可直接获取锁，省去了大量有关锁申请的操作，从而也就提供程序的性能。但是偏向锁是不会解锁的，所以若产生多个线程锁竞争的情况，则偏向锁修改的话会失败撤销并升级为轻量级锁，等待锁线程走到安全点，则进行新的锁竞争

* 轻量级锁：此时Mark Word 的结构也变为轻量级锁的结构，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，不会对其他线程进行阻塞，而是安排其他线程进行自旋等待，若自旋后还是不能获得锁，则会阻塞挂起，若还是不能获得，就会导致轻量级锁膨胀为重量级锁
* 自旋锁：自旋不会丢弃cpu使用权，自旋锁是虚拟机为了避免线程真实地在操作系统层面挂起进行的优化手段，主要为了避免线程之间切换时从用户态转换到核心态耗费大量时间成本，所以自旋锁假设当前线程可以通过几个空循环之后获得锁，所以会进行50-100个循环，直到获得锁或者失败直接在操作系统层面阻塞挂起等待，若还是不能获得，则会升级为重量级锁
* 锁消除：消除锁是虚拟机另外一种锁的优化，Java虚拟机在JIT编
译时(称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间

![synchronized_principle](/img/synchronized_principle.png)


**ReentranLock**
>显示锁，需要手动加锁和解锁，基于AQS实现
* 重入锁：可重入锁，即同步方法中若包含多个子流程，则当前线程可以重复获得锁，即
等到子流程都执行完毕得时候，其他线程才能获得锁

**AQS**
> Java并发编程核心在于java.concurrent.util包而juc当中的大多数同步器实现都是围绕着共同的基础行为，比如等待队列、条件队列、独占获取、共享获取等，而这个行为的抽象就是基于AbstractQueuedSynchronizer简称AQS，AQS定义了一套多线程访问共享资源的同步器框架，是一个依赖状态(state)的同步器，AQS的实现用到了大量循环

>AQS具备特性
* 阻塞等待队列
* 共享/独占
* 公平/非公平
* 可重入
* 允许中断



### Tools&CountDownLatch&Semaphore原理与应用
**JUC并发编程框架的Tools**
>包含5个工具类：
* Exeutors：线程池
* Semaphore：
* Exchanger(线程互换变量等)
* CyclicBarrier
* CountDownlatch


### Atomic&Unsafe魔法类详解
**Atomic原子操作**
>原子(atom)：指不能被进一步分割的最小粒子

>原子操作(atomic operation)：值的是不可被中断的一个或一系列操作，比如同步块的逻辑代码即是系列原子操作，一个代指cas操作

* 缓存行：缓存的最小操作单位
* 比较并交换：CAS(Compare and Swap) 操作，
* CPU流水线：
* 内存顺序冲突：



### Collections&Queue体系分析
### Executor线程池原理与源
### 实战手写ThreadPoolExecutor线程池
### Future&Fork/Join框架原理分析
### 定时任务&定时线程池
